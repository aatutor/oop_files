#include <algorithm>
#include <iostream>
#include <list>
using namespace std;
/*
	Функциональный объект, содержащий два поля:
	1. для хранения значения приращения (delta)
	2. для текущего значения генерируемого числа (current)
*/
class addNumberFrom
{
	int delta;
	int current;
/*
	Конструктор класса инициализирует значение приращения
	и текущее значение.
	Последнее может быть опущено, и тогда оно будет
	считаться равным 0
*/
  public:
	addNumberFrom(int number, int from = 0) 
			: delta(number), current(from) {}
/*
	Основа функтора — перегруженный оператор вызова
	функции — прибавляет значение приращения
	к текущему генерируемому числу
*/
	int operator()()
	{
		return current += delta;
	}
};
void main()
{
	//Вывод заголовка для таблицы умножения.
	cout << "TABLE:"
		 << "\n\n";
	cout << "----------"
		 << "\n\n";
	for (int i = 1; i <= 10; i++)
	{
		//Cоздание контейнера-списка.
		list<int> l(10);
/*
	Вызов алгоритма generate_n. Естественно,
	сам он не может ничего генерировать,
	однако последовательно перебирает значения,
	диапазон которых задан начальным
	итератором и количеством элементов списка.
	Для записи числа в каждое значение вызывается
	функция, на которую ссылается третий параметр:
*/
		generate_n(l.begin(), l.size(), addNumberFrom(i));
/*
	Но мы вместо функции подставляем перегруженный
	оператор вызова функции — объект addNumberFrom.
	Если вызов происходит впервые, то вызывается
	конструктор объекта. Он инициализирует поле
	delta значением переменной i,а поле current -
	значением по умолчанию второго параметра
	конструктора, т. е. 0.
	Таким образом, контейнер-список заполняется
	произведениями числа в переменной i и
	множителями от 1 до 10. В алгоритме generate_n
	используется метод size(), который возвращает
	количество элементов в списке.
	Если имеются начальный и конечные итераторы,
	тогда лучше воспользоваться алгоритмом
	generate.
*/
		//Собственно показ числа из контейнера-списка
		copy(l.begin(), l.end(), ostream_iterator<int>(cout, "\t"));
	}
}

/*
	1. Арифметические функторы:
		plus сложение x + y;
		minus вычитание x – y;
		multiplies умножение x ? y;
		divides деление x / y;
		modulus взятие остатка x % y;
		negate обращение знака –x;
	2. Функторы сравнения:
		equal_to равно x == y;
		not_equal_to не равно x != y;
		greater больше x > y;
		less меньше x < y;
		greater_equal больше или равно x => y;
		less_equal меньше или равно x <= y;
	3. Логические функторы:
		logical_and логическое «и» x && y;
		logical_or логическое «или» x || y;
		logical_not логическое «не» ! x.
*/